int createAndApply(matrix_folder *theta) /* theta */

{



	/* All these are defined outside this function */

	//nettoyer ca, y a des trucs répétés

	PRL_Point input;

	const CUDA_FLOAT_REAL radius = 12.0f;

	const int mox = 512, moy = 512;

	const int moxy = mox * moy;

	// Get number of modes

	std::vector<int> theta_dim = theta->get_matrix(0)->get_matrix_dimension();

	const int mox = theta_dim.at(0);	// modes in x direction

	const int moy = theta_dim.at(1);	// modes in y direction

	const int moz = theta_dim.at(2);	// modes in z direction

	const int moxy = mox * moy;	// modes in horizontal plane

	const int num_elements_real = 2 * (mox - 1) * moy;	// number of elements in real space

	bool quit = false;



	int **mask = NULL;

	mask = new int*[moy];



	CUDA_FLOAT_REAL* mask_data = NULL; /// How to fill it up? (how to fix a suitable temperature)

	CUDA_FLOAT_REAL factor = 1.0f;

	int num_entries = 1;

	/* create a 2d array for the mask */

	for (i = 0; i < xSz; i++)

	{

		temperature[i] = new int[mox];

		for (j = 0; j < ySz; j++)

		{

			temperature[i][j] = 0;

		}

	}



	// prepare number of real modes

	std::vector<int> dim_real(3);

	dim_real[0] = 2 * (mox - 1);

	dim_real[1] = moy;

	dim_real[2] = moz;

	matrix_device_real* theta_real = new matrix_device_real(dim_real);



	cufftHandle c2r_plan;

	cufftHandle r2c_plan;



	//create fft plan

	cufftPlan2d(&c2r_plan, num_y, num_x, CUFFT_TYPE_C2R);

	//create inverse fft plan

	cufftPlan2d(&r2c_plan, num_y, num_x, CUFFT_TYPE_R2C);



	while (!quit) /// sort of (not a loop)

	{

		update_input(&input);

		init_mask_physical_space_circle(mask, moy, mox, (CUDA_FLOAT_REAL)radius);

		/*prototype:

		(int* mask, int moy, int moxs, CUDA_FLOAT_REAL radius)*/



		///



		// Transform theta

		for (int i = 0; i < moz; i++) {

			if (CUFFT_SUCCESS != CUFFT_EXEC_C2R(c2r_plan, theta->get_matrix(0)->get_data() + i * moxy, theta_real->get_data() + i * num_elements_real)) {

				DBGSYNC();

				EXIT_ERROR2("c2r-fft failed", ::cudaGetErrorString(cudaGetLastError()));

			}

		}



		/// Pass the input point to the function to modify col_index and mox_index

		apply_mask(theta, mask_data, int* mask, factor, moxy, num_entries);/*prototype:

		(CUDA_FLOAT_REAL* input_output, CUDA_FLOAT_REAL* mask_data, int* mask, CUDA_FLOAT_REAL factor, int num_xy, int num_entries)*/



		// Transform theta back

		for (int i = 0; i < moz; i++) {

			if (CUFFT_SUCCESS != CUFFT_EXEC_R2C(r2c_plan, theta_real->get_data() + i * num_elements_real, theta->get_matrix(0)->get_data() + i * moxy)) {

				DBGSYNC();

				EXIT_ERROR2("r2c-fft failed", ::cudaGetErrorString(cudaGetLastError()));

			}

		}



		return 0;

	}

	cufftDestroy(r2c_plan);

	cufftDestroy(c2r_plan);

	delete theta_real
