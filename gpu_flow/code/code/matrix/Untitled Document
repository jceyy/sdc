#include "masking.h"

/*__device__ static int get_global_index(){
    return (threadIdx.x + (threadIdx.y + (threadIdx.z + (blockIdx.x + (blockIdx.y + (blockIdx.z)
            * gridDim.y) * gridDim.x) * blockDim.z) * blockDim.y) * blockDim.x);
}*/

__global__ static void init_mask_physical_space_rectangle(int* mask, int columns, int rows, CUDA_FLOAT_REAL width)
{
    int total_index = get_global_index();
    int col_index = 0, row_index = 0, matrix_index = 0;
    get_current_matrix_indices(col_index, row_index, matrix_index, total_index, columns, rows, 1);

    // use a mask
	if(total_index < columns*rows){
		//init all with zeros
        int mask_val = 0;

        // rectangular mask
        if((col_index < width * columns)
                || (col_index > (1-width) * columns)
                || (row_index < width * rows)
                || (row_index > (1-width) * rows)) {
            mask_val = 1;
        }

        mask[total_index] = mask_val;
	}
}

// radius in fraction of max radius
__global__ static void init_mask_physical_space_circle(int* mask, int columns, int rows, CUDA_FLOAT_REAL radius)
{
    int total_index = get_global_index();
    int col_index = 0, row_index = 0, matrix_index = 0;
    get_current_matrix_indices(col_index, row_index, matrix_index, total_index, columns, rows, 1);

	//use a mask
	if(total_index < columns*rows){
        // init all with zeros
        int mask_val = 0;

        // circular mask
        CUDA_FLOAT_REAL distance_from_center_sq = (col_index - 0.5 *  columns)*(col_index - 0.5 * columns) + (row_index - 0.5 * columns)*(row_index - 0.5 * rows);

        int min_len = (rows < columns)?(rows):(columns);
        CUDA_FLOAT_REAL max_distance_from_center = radius * 0.5 * min_len;
        if(distance_from_center_sq > max_distance_from_center * max_distance_from_center) {
            mask_val = 1;
        }

        mask[total_index] = mask_val;
	}
}

__global__ static void apply_mask(CUDA_FLOAT_REAL* input_output, CUDA_FLOAT_REAL* mask_data, int* mask, CUDA_FLOAT_REAL factor, int num_xy, int num_entries)
{
    int total_index = get_global_index();

    // check if thread is valid
    if(total_index < num_entries) {

        CUDA_FLOAT_REAL entry;
        if(mask[total_index % num_xy] == 0) {
            entry = input_output[total_index];
        } else {
            entry = mask_data[total_index];
        }
        input_output[total_index] = factor * entry;
	}
}

/** ********************* **/
/** PRINCIPLE OF THE CODE **/
/** ********************* **/


int createAndApply(matrix_folder *theta) /* theta */

{

	/* All these are defined outside this function */

	//nettoyer ca, y a des trucs répétés

	PRL_Point input;

	const CUDA_FLOAT_REAL radius = 12.0f;

	
	// Get number of modes

	std::vector<int> theta_dim = theta->get_matrix(0)->get_matrix_dimension();

	const int mox = theta_dim.at(0);	// modes in x direction

	const int moy = theta_dim.at(1);	// modes in y direction

	const int moz = theta_dim.at(2);	// modes in z direction

	const int moxy = mox * moy;	// modes in horizontal plane

	const int num_elements_real = 2 * (mox - 1) * moy;	// number of elements in real space

	


	bool quit = false;



	int **mask = NULL;

	mask = new int*[moy];



	CUDA_FLOAT_REAL* mask_data = NULL; /// How to fill it up? (how to fix a suitable temperature)

	CUDA_FLOAT_REAL factor = 1.0f;

	int num_entries = 1;

	/* create a 2d array for the mask */

	for (i = 0; i < xSz; i++)

	{

		temperature[i] = new int[mox];	//temperature hasnt been initialized yet

		for (j = 0; j < ySz; j++)

		{

			temperature[i][j] = 0;

		}

	}



	// prepare number of real modes

	std::vector<int> dim_real(3);

	dim_real[0] = 2 * (mox - 1);

	dim_real[1] = moy;

	dim_real[2] = moz;

	matrix_device_real* theta_real = new matrix_device_real(dim_real);



	cufftHandle c2r_plan;
	cufftHandle r2c_plan;



	//create fft plan

	cufftPlan2d(&c2r_plan, num_y, num_x, CUFFT_TYPE_C2R);

	//create inverse fft plan

	cufftPlan2d(&r2c_plan, num_y, num_x, CUFFT_TYPE_R2C);



	while (!quit) /// sort of (not a loop)

	{

		update_input(&input);

		init_mask_physical_space_circle(mask, moy, mox, (CUDA_FLOAT_REAL)radius);

		/*prototype:

		(int* mask, int moy, int moxs, CUDA_FLOAT_REAL radius)*/



		///



		// Transform theta

		for (int i = 0; i < moz; i++) {

			if (CUFFT_SUCCESS != CUFFT_EXEC_C2R(c2r_plan, theta->get_matrix(0)->get_data() + i * moxy, theta_real->get_data() + i * num_elements_real)) {

				DBGSYNC();

				EXIT_ERROR2("c2r-fft failed", ::cudaGetErrorString(cudaGetLastError()));

			}

		}



		/// Pass the input point to the function to modify column and row index

		apply_mask<<<grid_real,block_real>>>(theta->get_data(), mask_data, int* mask, factor, moxy, num_entries);//prototype:
		apply_mask<<<grid_real,block_real>>>(theta_real->get_data(), theta_frozen->get_data(), mask_frozen, 1./num_elements_real, num_elements_real, num_elements_real * moz);

		//(CUDA_FLOAT_REAL* input_output, CUDA_FLOAT_REAL* mask_data, int* mask, CUDA_FLOAT_REAL factor, int num_xy, int num_entries)*/



		// Transform theta back

		for (int i = 0; i < moz; i++) {

			if (CUFFT_SUCCESS != CUFFT_EXEC_R2C(r2c_plan, theta_real->get_data() + i * num_elements_real, theta->get_matrix(0)->get_data() + i * moxy)) {

				DBGSYNC();

				EXIT_ERROR2("r2c-fft failed", ::cudaGetErrorString(cudaGetLastError()));

			}

		}



		return 0;

	}

	cufftDestroy(r2c_plan);

	cufftDestroy(c2r_plan);

	delete theta_real
